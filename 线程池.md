# Annotation
>注解是java5开始的，可以用于包，类，方法，变量等，比如常见的@Override
## 元数据
>元数据就是描述数据的数据，对数据及信息资源的的描述性信息，比如一个文本文件，有创建时间，文件大小，拥有者等信息。
>java中元数据以标签形式存在代码中，他们不影响程序代码的编译和执行，通常用来生成其他文件。java中的javadoc和注解都属于元数据。

## 元注解
>元注解就是定义注解的注解，（注解是由我们定义的，元注解是基础。就像person这个类使我们定义的，但是class是"元类"）
### @Retention
>该注解用于定义注解保留策略,即定义的注解类在什么时候存在(源码阶段 or 编译后 or 运行阶段).该注解接受以下几个参数:RetentionPolicy.SOURCE,RetentionPolicy.CLASS,RetentionPolicy.RUNTIME.
### @Target
作用目标    含义
@Target(ElementType.TYPE)   用于接口(注解本质上也是接口),类,枚举
@Target(ElementType.FIELD)  用于字段,枚举常量
@Target(ElementType.METHOD) 用于方法
@Target(ElementType.PARAMETER)  用于方法参数
@Target(ElementType.CONSTRUCTOR)    用于构造参数
@Target(ElementType.LOCAL_VARIABLE) 用于局部变量
@Target(ElementType.ANNOTATION_TYPE)    用于注解
@Target(ElementType.PACKAGE)    用于包
### @Inherited
>默认情况下,我们自定义的注解用在父类上不会被子类所继承.如果想让子类也继承父类的注解,即注解在子类也生效,需要在自定义注解时设置@Inherited.一般情况下该注解用的比较少.
### @Documented
```
该注解用于描述其它类型的annotation应该被javadoc文档化,出现在api doc中.
比如使用该注解的@Target会出出现在api说明中.
```
### @interface
>用于声明注解类的关键字，使用该注解表示自动继承java.lang.annotation.Annotation，该过程交给编译器完成。
```
#定义一个注解
public @interface Override{

}

```

## 系统注解
>java设计者已经为我们自定义了几个常用的注解,我们称之为系统注解,主要是这三个:
>@Override  用于修饰方法,表示此方法重写了父类方法
@Deprecated 用于修饰方法,表示此方法已经过时
@SuppressWarnnings  该注解用于告诉编译器忽视某类编译警告

## 自定义注解
```
public @interface 注解名 {定义体}
定义体就是方法的集合,每个方法实则是声明了一个配置参数.方法的名称作为配置参数的名称,方法的返回值类型就是配置参数的类型.和普通的方法不一样,可以通过default关键字来声明配置参数的默认值.

#自定义例子
@Documented
@Target(ElementType.CONSTRUCTOR)
@Retention(RetentionPolicy.RUNTIME)
public @interface UserMeta {
    public int id() default 0;

    public String name() default "";

    public int age() default ;
}
```
### 注解处理器
>注解定义后，还有定义注解处理器控制如何处理注解中的值
#### 编译时注解处理器
>Annotation Processing Tool用于在代码编译期对注解进行处理
#### 运行时注解处理器
>运行时注解处理器主要靠反射实现。
>可以通过读取运行时的注解，可以通过获取到某个类的AnnotatedElement对象，然后获取Annotation信息。
### 使用@UserMeta自定义注解
```
#常用函数
getAnnotations
getAnnotations(Class<T> annotationClass) //返回特定类型的注解
```
```
public class User {
    private int id;
    private int age;
    private String name;

    @UserMeta(id=1,name="dong",age = 10)
    public User() {
    }


    public User(int id, int age, String name) {
        this.id = id;
        this.age = age;
        this.name = name;
    }

  //...省略setter和getter方法

    @Override
    public String toString() {
        return "User{" +
                "id=" + id +
                ", age=" + age +
                ", name='" + name + '\'' +
                '}';
    }
}

```
```
#我们期望通过注解实现为对象注入属性值id，name，age
#isAnnotationPresent 判断是否存在某类注解。getAnnotation取出该注解。
public class AnnotationProcessor {

    public static void init(Object object) {

        if (!(object instanceof User)) {
            throw new IllegalArgumentException("[" + object.getClass().getSimpleName() + "] isn't type of User");
        }

        Constructor[] constructors = object.getClass().getDeclaredConstructors();
        for (Constructor constructor : constructors) {
            if (constructor.isAnnotationPresent(UserMeta.class)) {
                UserMeta userFill = (UserMeta) constructor.getAnnotation(UserMeta.class);
                int age = userFill.age();
                int id = userFill.id();
                String name = userFill.name();
                ((User) object).setAge(age);
                ((User) object).setId(id);
                ((User) object).setName(name);
            }
        }
    }
}
#测试 main函数

public class Main {

    public static void main(String[] args) {
        User user = new User();
        AnnotationProcessor.init(user);
        System.out.println(user.toString());
    }
}



```