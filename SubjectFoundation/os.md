# 第二章  进程的描述和控制

- 进程的状态
  进程：具有独立功能的程序在数据集合中运行的过程，他是系统调度和分配资源的的一个独立单位。
  进程的三种基本状态：就绪（ready），执行（running），阻塞（block）
  进程的创建状态和终止状态。​

- 状态转换图![img](https://api2.mubu.com/v3/document_image/d3dcb653-0b29-4d53-82c9-4573e30791fc-6012434.jpg)

- 进程的同步与互斥

  进程同步的主要任务是对多个相关进程在执行次序上进行协调。
  同时要互斥的访问资源。

  - 两种制约关系
    间接制约：共享系统资源，如cpu，i/o设备。
    直接制约:功能合作，A是输入进程，B是计算进程。

  - 临界资源：硬件资源，如打印机，磁带机等

  - 临界区：每个进程中访问临界资源的代码称为临界区。

- 同步与互斥问题

  - 生产者-消费者问题

    有一群生产者进程在生产产品，并提供给消费者进程消费。为了两者并发执行，在两者之间设置了一个具有n个缓冲区的缓冲池。生产者和消费者都与缓冲池交互。不允许生产者向已满的缓冲池投放产品，也不允许消费者从空的缓冲池获取产品。

    - 缓冲池的属性和操作
      in：存指针下标，投放产品+1
      out：取指针下标，取出产品+1
      count：池子内产品数，投放产品+1，取出产品-1​
      取出产品：buffer[out] out=(out+1)%n count--;
      投放产品：buffer[in]  in=(in+1)%n count++;

    - 利用记录型信号量解决生产者-消费者问题
      使用mutex实现进程对缓冲池的互斥访问
      使用empty和full分别表示缓冲池中空缓冲区和满缓冲区的数量。只要缓冲池未满则可投放，未空则可取。
      wait()申请一个资源，signal（）释放一个资源。
      投放产品操作：wait(empty);wait(mutex); buffer[in]=nextp;in=(in+1)%n;signal(mutex);signal(full);
      取产品操作：​​wait(full);wait(mutex); nextc=buffer[out];out=(out+1)%n;signal(mutex);signal(empty);

    - 利用AND信号量解决生产者-消费者问题
      用Swait(empty,mutex)替代wait(empty)和wait(mutex)
      用Ssianal(mutex,full)替代signal(mutex)和signal(full)；

  - 哲学家进餐问题

    五个哲学家共用一个圆形餐桌，桌子上有5只筷子和五只碗。他们的生活
    ​方式是交替的进行思考和进餐。平时进行思考，饥饿时拿起左右的筷子进餐，只有拿到两只筷子时才能进餐，进餐完毕，放下筷子思考。

    - 利用记录型信号量解决
      临界资源为筷子，可以用一个信号量表示一个筷子，由五个信号量构成信号量数组。semaphore chopsticks[5]={1,1,1,1,1};
      哲学家活动描述为：
      do{
         wait(chopstick[i]);
         wait(chopstick[(i+1)%5]);
      //eat
        signal(chopstick[i]);
         signal(chopstick[(i+1)%5]);
      //think
      ​}while(TRUE)

    - 利用AND型信号量

  - 读者-写者问题

    - 利用记录型信号量
      wmutex：实现读和写的互斥。
      ​readcount：表示正在读的进程数目。
      rmutex：实现多个reader进程对readcount这个临界资源的互斥访问。
      reader：
      ​void reader（）{
          do{
            wait(rmutex);
            if(readcount==0) wait(wmutex);
          readcount++;
          signal(rmutex);
         ...
          perform read  operation;
        ... 
        wait(rmutex);
        readcount--;
         if(readcount==0)  signal(wmutex);
         signal(mutex);
        }while(TRUE);​​​​​
      ​}
      ​}
      writer：​
      void  writer()
      {
           wait(wmutex);
      perform write operation;
      signal(wmutex);​
      ​}​whille(TRUE);
      vodi main()
      {
            cobegin
                Reader(); Writer();
           coend​
      ​}​

    - 利用信号量集机制
      swait(L,1,1)申请一个L资源
      swait(L,1,0）开关，不申请资源。若L》1，可进入。若为0不可。

# 第三章 处理机调度与死锁

## 作业与作业调度

### FCFS
先来先服务，常与其他调度方法结合。如设置多个队列，每个优先级一个队列，队列内按照FCFS。

### SJF
短作业优先原则。
实际中，短作业占很大比例，为了让他们优先执行，产生了此算法。
缺点：1要获取作业时间
2使长作业饥饿
3未考虑紧迫程度。​

### PSA
基于外界给出的作业优先级，进行调度。
FCFS的优先级是作业等待的时间，SJF是的优先级是作业长短

## 进程调度算法

### RR

- 基本原理
  根据fcfs将进程排成长列，设置每过固定时间间隔产生一次中断，激活系统中的进程调度程序，将cpu分配给队首的进程。当他的时间片耗完或执行完毕时，再次调度。

- 进程切换时机
  1时间片未用完，进程完成，则立刻激活调度程序。
  2时间片用完，开始调度程序。若当前进程未执行完，则将其插入队尾。

### 优先级调度算法

#### 优先级调度算法的类型
1非抢占式：一旦把处理机资源分配给优先级最高的进程，进程一直执行直至完成，或因进程发生某事件而放弃，才会再次调度。
2抢占式：将处理器分配给优先级最高的进程，但在其执行过程中，若出现了优先级更高的进程，就将处理机分配给新来的进程。

#### 优先级的类型

#### 静态优先级
进程创建时确定，整个运行期间不变。使用0-255的一个数表示，又称优先数。
1进程类型：系统进程，用户进程
2进程对资源的需求：对资源要求少的进程赋予较高的优先级
3用户要求​​：根据进程的紧迫程度及用户所付费用多少确定优先级。
​

#### 动态优先级
在创建程序之初赋予优先级，然后其值随时间增加和进程推进而改变。例如，规定等待队列中的进程随着等待时间增加，优先级提高。例如，在抢占式优先级调度中，当一个进程执行时，随着时间增加，其优先级降低，可防止长作业霸占处理机。

### 多队列调度算法
单一的调度算法无法满足复杂的需求，因此设置多个队列，每个队列装入同一类型的进程，每个队列使用不同的调度算法。

### 多级反馈队列调度算法
即对内FCFS+多个不同优先级的队列，但优先级越高的队列，分配的时间片越少。

### 基于公平原则的调度算法

####  保证调度算法
每个进程平分时间

#### 公平分享调度算法
  每个用户拥有的进程数不同，必须保证每个用户所使用的时间相同。

# 死锁概述

  -## 死锁的定义
    当发生死锁时，这组死锁进程中的每一个进程，都在等待另一个死锁进程所占有的资源。

  ## 产生死锁的必要条件
    1互斥：在一段时间内，某资源只能被一个进程占有
    2请求和保持：进程持有一个资源，再去请求其他进程占有的资源。
    3不可抢占：进程持有的资源在进程结束前不可分配给其他进程
    4循环等待​：发生死锁的进程之间互相等待其他人持有的资源。

## 预防死锁

  - 破坏请求和保持
    1第一种协议
    进程运行前一次性请求所有资源
    2第二种协议
    允许先申请初期所需的资源，使用完后一次全部释放，再申请所需资源。​

  - 破坏不可抢占

  - 破坏循环等待
    给资源规定一个序号级，按照序号递增的顺序请求资源。若需要多个同类资源必须一起请求。若需要序号低的资源，必须放弃当前持有资源。

## 避免死锁问题-银行家算法

### 系统安全
  允许冬天的申请资源，但是在进行资源分配时，先计算资源分配的安全性，防止系统进入不安全状态。所谓安全状态就是，系统可以按照某一顺序推进进程，分配资源，使每个进程都能顺利完成。若无法找到该顺序，则不分配该资源。

### 利用银行家算法避免死锁

  为了实现银行家算法，每个新进程进入系统时，它必须申明在运行过程中，可能需要的每种资源的最大单元数，其总数应不超过系统所拥有的资源总量。当进程请求资源时，系统先确定是否有足够的资源。若有，再进一步计算资源分配给进程后，系统是否会处于不安全状态。如果不会，再分配给他。

  ####  银行家算法数据结构
    1可利用资源向量Available。这是一个含有m个元素的数组，如Available[j]=k,表示j类资源有k个。
    2最大需求矩阵Max。这是一个n×m的矩阵，它定义了系统中n个进程的每一个进程对m类资源的最大需求量。如Max[i,j]=k,表示进程i需要j类资源的最大数目为k。​
    3分配矩阵Allocation。这是一个n×m的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如Allocation[i,j]=k,表示进程i分到了j类资源k个。
    4需求矩阵need。Need[i,j]表示，进程i还需要j类资源k个才能完成其任务。​
    Need[i,j]=Max[i,j]-Allocation[i,j]

  ####  银行家算法
    Requesti是进程Pi的请求向量，如果Requesti[j]=k,表示Pi需要K个j类资源,Pi发出请求后，系统按如下步骤：
    1若Requesti[j]<=Need[i,j],转向2.否则认为出错。
    2若Requesti[j]<=Available[j],转向3.否则认为尚无足够资源。
    3若把资源分配给Pi，并分配数据结构的值。
    Available[j]=Available[j]-Requesti[j];
    Allocation[i,j]=Allocatin[i,j]+Requesti[j];
    Need[i,j]=Need[i,j]-Requesti[j];
    4检查是否处于安全状态，否则撤销分配。​​​

###  安全性算法
>（即把资源全部分出去，看看是否有进程没分到（为false），若有即不安全。）

- （1）设置两个向量
  1工作向量Work，表示可提供的系统资源总数，执行安全算法开始时，他等于Available。
  2Finish,他表示系统是否有足够的资源分配，开始时Finishi[i]=false.当有足够资源时，再令Finish[i]=true.

- （2）寻找进程
  从进程集合中找到满足如下条件的进程
  1Finish[i]=false
  2Need[i,j]<=Work[j];
  若找到执行（3），否则执行（4）.​​

- （3）当进程获得资源后，可顺利执行完毕并释放资源，故：
  Work[j]=Work[j]+Allocation[i,j];
  Finish[i]=true;
  go to  step 2;​

- (4)如果所有进程都满足Finish[i]=true,则表示系统处于安全状态。

### 银行家算法实例

# 第四章  存储器管理

## 分页问题

- 分页存储管理的基本方法
  分页地址中的地址结构如下：页号＋偏移量
  例子：给定逻辑地址A和页面大小L。则页号P和页内地址d可按下式求得：
  P=INT[A/L],d=[A]MODL
  ​​页表：为了能在内存中找到每个页面对应的物理块，系统为每个进程创建了一张页面映像表，简称页表。可加控制字段控制读写。

## 分段问题

### 选用分段存储方式的原因
  1方便编程：通常用户把自己的作业按照逻辑关系分为若干个段，每个段从0开始编址，并有自己的名字和长度。因此程序员希望使用段名+段内偏移量访问逻辑地址。
  2信息共享：分页系统的页只是存储信息的物理地址，如果要共享一段逻辑过程，可能分散在几十个页中。而分段可以集中他们。
  3信息保护：信息保护是以逻辑单位为基础的，如以过程，函数和文件为基础。如我们希望程序段A只执行，不能读写，只需在该段加标识。而分页系统很分散。
  4动态增长：在使用过程中，由于数据量不断增加，使数据段动态增长，它所需要的空间也会增加。但到底需要多少，事先无法知道，分段系统可以很好处理这个问题。​

###  基本原理
  分段地址中的地址为段号+段内地址
  在分段管理方式中，作业的地址被分为若干个段。如主程序段，子程序段X等。每个从0开始编制，使用连续的空间。各段的长度不同，最长有64K个段，每个段最大长度为64Kb.
  每个进程建立一个段映射表，称为段表，记录每个段起始地址和大小。实现从逻辑地址到物理地址的映射。
  通过段表寄存器依次查找段号和段内地址，确定物理地址。
  ​

## 分段分页区别
1页是信息的物理单位
2页的大小固定由系统决定。
3分页的用户程序地址空间唯一，分页是系统行为，故用户程序是线性的。​而分段是用户行为，空间表现为二维。

# 第五章 虚拟存储器

##  虚拟存储器的定义和特征
  1具有请求调入和置换功能，能从逻辑上对内存容量进行扩充的一种存储器系统。其逻辑容量由内存容量和外村容量之和决定，运行速度接近内存，成本接近外存。
  特征：1多次性：指数据不用一次性装入，而是按需分批次装入。
  2对换性：能换进换出，允许暂不使用的数据和代码换出。
  3虚拟性​：从逻辑上扩充内存容量。

##  分页请求系统
  在分页系统的基础上加入了请求调页功能和页面置换功能所形成的虚拟存储系统。
  硬件支持：1请求分页的页表机制
  2缺页中断机制
  3地址变换机构​

##  请求分段系统
  在分段系统的基础上增加请求调段及分段置换功能所形成的段式虚拟存储系统。

- 虚拟存储器的页面置换算法

# 第六章 输入输出系统

##  磁盘的性能和调度

  磁盘的性能主要通过以下方式改进
  1选择好的调度算法，减少寻到时间
  2提高i/o速度，以此提高访问速度。
  3使用冗余技术，提高可靠性。

  - 磁盘调度算法：先来先服务

# 第八章 磁盘存储器的管理

## 文件存储空间管理问题

  - 位视图法
    使用一位二进制表示是否空闲，0为空闲。为m×n个数，可描述为map[m,n]
    盘块分配时步骤：1找到为0的二进制位，即空闲
    2计算盘号=n(i-1)+j，i行，j列，每行n个。
    3令map[i,j]=1;​
    盘块回收步骤：1将盘号转换为行号列号，
    i=(b-1)DIV n+1;
    j=(b-1)MOD n+1;
    2修改位示图：map[i,j]=0;​​​

  - 成组链接法
    结构：1N：表示可用空闲块数。
    ​2最多存储100个盘块号，表示空闲盘块
    （其中有一个指向下一组盘块）
    最后一组盘块0号位存储0，作为结束标志。

# 其他

## 大小端模式
  我们以一个字节为单位存储信息，一个字节为8bit。对于大于一个字节的数据，如何组织其顺序和结构，分为两种方案
  1小端模式：数据的高位放在地址的高位，数据的低位放在地址的低位。
  2大端模式，反之

##  逻辑运算

  与或非

  - 左移右移
    1算术左移，逻辑左移：右边补0，左边溢出裁剪。若左侧不溢出，相当于原数值乘以2的n次方（移动n位）。
    2循环左移：左侧溢出添加到右侧。
    3带进位的循环左移：左侧有一个符号位。

    1算数右移：左侧添加符号位，
    2逻辑右移：左侧补0.
    3循环右移：左侧添加0，右侧溢出添加到左侧。
    4带进位的循环右移：左侧多一个符号位。
    ​

## 内存和调用

  - 栈
    数据结构中为先进后出。
    在内存中，栈自顶向下分配，先使用最高地址。
    栈只用于短期存储，存储局部变量，参数和返回地址。主要用途为管理函数之间的数据交换。
    栈的布局：
    栈自顶向下，保存着一个函数调用所需要的维护信息，称为堆栈帧或活动记录，其包括：
    1函数返回地址和参数
    2临时变量：包括函数的非静态局部变量以及编译器生成的其他局部变量。
    3保存上下文:：包括在函数调用前后保持不变的寄存器。
    x86中的栈，由esp和ebp构成。
    esp：栈指针，包含指向栈顶的内存地址，随压入弹出改变。
    ebp：栈基址寄存器，在一个函数中保持不变，它作为定位器确定局部变量和参数的位置。

  - 堆
    堆是程序运行期动态申请内存空间的主要途径，由程序员创建和销毁。

## 中断和异常

  - 错误类异常
    错误类异常通常可以纠正，cpu未执行下一条指令，程序可恢复执行。如内存页错误。

  - 陷阱类异常
    报告此类异常时，导致异常的指令已执行完毕。

  - 中止类异常
    一般由硬件错误和系统表中包含非法值或不一致的状态。

  - 中断/异常处理
    中断和异常处理的核心数据结构是中断描述符表IDT。当中断和异常发生时，cpu通过IDT定位处理例程的地址，然后去执行该例程。

##  函数调用约定

  当一个函数被调用，函数的参数会被传递给被调用的函数，返回值会返回给调用函数。函数调用约定就是描述参数，返回值怎么传递和由谁平衡堆栈。
  1cdecl，参数从右向左传递，也是放在堆栈中。平衡由调用函数执行。返回值放在eax中
  ​2stdcall，由右至左的方式入栈，函数自身清理堆栈，返回值在eax中。
  3fastcall，使用ecx和edx传送两个双字或更小的参数，剩下的参数按照从右至左的方式入栈。自身清理堆栈，返回值在eax中。
  4naked
  5pascal
  6thiscall

  - 寄存器
    eax是累加器，加法乘法的缺省寄存器。
    ebx是基地址寄存器，内存寻址时存放基地址。
    ecx计数器，是rep前缀指令和loop指令的内定计数器。
    edx存放整数除法的余数。
##  文件格式

  - ELF文件格式

    ELF时运行在unix下的可执行文件。

    - 目标文件
      目标文件是指源代码经过编译程序生成的能被cpu直接识别的二进制代码。
      目标文件分为三类：
      1可重定位文件Relocatable File，包含适合于其他目标文件连接来创建可执行文件或者共享目标文件的代码或数据。
      2可执行文件Excutable File，包含适合于执行的一个程序，此文件规定了exec（）如何创建一个程序和进程映像。
      2共享目标文件。包含可在两种上下文中连接的代码和数据。

    - 结构
      http://blog.nsfocus.net/sample-analysis-manual-theory/
      1ELF Header
      2程序头部表
      3节区头部表

  - PE文件格式
    结构：ms-dos头部，dos stub，pe文件头，区块表，输入表，输出表。