

# 基本

>linux操作系统由4部分组成：内核：kernel，shell，文件系统和应用程序。
>
>linux内核由五个子系统组成：进程调度，内存管理，虚拟文件系统，网络接口，进程间通信。io系统，磁盘等。

# 内存寻址

### 内存地址

##### 逻辑地址：在分段结构中使用，使用一个segment段和一个offset偏移量表示，offset表示断开始到实际地址的距离。

##### 线性地址：32位无符号整数，表示一段地址可高达4GB，将逻辑地址加上基地址就是线性地址。

##### 物理地址：芯片级内存单元寻址，与电信号对应。

cpu控制单元通过分段单元将逻辑地址转为线性地址，通过分页单元将线性地址转为物理地址。

### 硬件分段单元

>一个逻辑地址由一段标识符和一个指定段内相对地址的偏移量。

为了快速检索段选择符：段标识符，处理器用段寄存器存放段选择符。共有6个：cs,ss,ds,es,fs,gs.

其中三个有特殊用途：
cs 代码寄存器

ss 栈段寄存器，指向存放当前程序栈的段。

ds 数据段寄存器，存放静态数据和外部数据的段。

### 段描述符

每个段描述符表示，存储段的特征，存在全局描述符表中或局部描述符表。

组成：1type域：米哦啊书段的类型2s，表示是否为系统段。3第一个字节的线性地址，用于地址转化。

### 段选择符

当选择符被装入段寄存器，相应的段描述符装入cpu寄存器。这个段的逻辑地址转换不必查找gdt和ldt，直接在寄存器中。

组成：1索引，在gdt或ldt中入口2在ldt还是gdt3段选择符放入cs时优先级

### 段选择符和段描述符

段描述符8字节，段选择符16位长。

段选择符高13位乘以8得到在ldt或gdt中相对地址，因为选择符前13位为索引。

例：gdt起始地址a，段选择符索引号2，则在gdt实际地址=a+相对地址:2*8

### 段单元

逻辑地址转为线性地址

1找到描述符表

2取出索引号，求出描述符在gdt地址。

3根据段描述符域基地址和逻辑地址偏移量求出线性地址。

### 硬件中的分页单元

>将线性地址转为物理地址分为两步，第一步使用的转换表称为页目录，第二种使用的称为页表。
>
>正在使用的页目录表的物理地址放在cr3中，线性地址的目录域决定指向页目录表哪一项，即指向哪个页表。随后，页表域决定页表的一项，此项包含页框所在物理地址。偏移量决定本页框内相对位置。

目录和页表域都10位长，组成:

### 拓展分页

将页框大小设为4kb或4mb，4mb页目录表项的地址低22位无效。4kb低12位无效。使用page size标识大小。

### 硬件保护方案

段有读写执行三种权限，页只有读写。

线性地址有64位。

分页举例执行流程:

1目录域用于选择页目录的对应目录项

2页表域选择页表对应的页框

3偏移量用于在页框中查找位置。

### 三级分页

最高21位不用，13位偏移量：叶匡大小8kb，三个10位的页表域。

### 硬件高速缓存

解决处理器和动态ram或dram之间近10倍的速度差距，用来存放程序和数据结构。

行：由多个连续字节构成，在dram和ram或sram之间进行数据传送。

dram动态随机存取器：电容表示数据，电荷流失需要周期充电

sram静态随机存取器：只要保持通电，数据不消失。

高速缓冲控制器有一个入口数组，每个入口对应高速缓存存储器一个行。

入口：一个tag，描述行的几个flag。

tag：一些位组成，映射对应行。

这块控制器地址构成：tag，控制器子集索引，行内偏移量。

### TLB转换后高速缓存

线性地址转换后，物理地址存储在tlb中。

invlpg使tlb一个单项失效。

### linux三级分页

页全局目录，页中间目录，页表

自动的线性地址转换实现了：1每个进程拥有不同物理地址空间，对应它自己的全局目录和自己的页表集合。进程切换时，将cr3寄存器内容存在tss段中，再把另一个tss段的值装入cr3中。

### 线性地址域

### 页表处理函数

##### PAGE_SHIFT

偏移量位数

log 页的大小，x86页大小为4096.

##### PMD_SHIFT

二级页表映射的地址位数

PMD_SIZE页中间目录单独表项映射的区域大小，即一个页表区域。2的22次方，4MB.

##### PGDIR_SHIFT

一级页表区域大小位数

PGDIR_SIZE,全局目录一个表项映射区域大小，即一个页目录大小。4mb.

##### PTRS_PER_PTE,PTRS_PER_PMD,PTRS_PER_PGD

页表，页中间目录，页全局目录表项个数。



### 页表的处理

pte_t，pmd_t和pgd_t为32位分别描述页表，页中间目录和页全局目录的一个表项。

pgprot_t为32位，描述单独表项保护标志。



# 进程

### 进程描述符

>task_struct结构,包含进程相关信息。

##### 进程的状态

可运行状态：TASK_RUNNING,cpu上运行或准备执行

可中断的等待状态：TASK_INTERRUPTIBLE，被挂起，直到一些条件为真。为真后，回到TASK_RUNNING状态。

不可中断状态:TASK_UNINTERRUPTIBLE,与上一个类似，把信号传递到睡眠的过程中，不能改变状态。

暂停状态:TASK_STOPPED,执行被暂停，收到SIGSTOP,SIGTSTP,SIGTTIN,SIGTTOU后进入暂停。当被其他进程监控，如debug时，任何信号都可以让他暂停。

僵死状态:TASK_ZOMBIE，执行被终止，父进程发布wait之前不可丢弃死进程的信息。

##### 标识一个进程

内核对进程描述符的引用大多通过进程描述符进行。

进程描述符中包含pid，pid中导出描述符指针，以便kill进程。

##### 任务数组

大小为NR_TASKS的全局静态数组，其中元素为进程描述符指针。

##### 进程描述符存放

存放在动态内存中。

进程描述符在下即内存开始处，内核态的进程栈在上即内存末端。

esp寄存器是cpu栈指针，存放栈顶位置。

c语言使用联合结构表达stack加描述符。

union task_union{

struc.task_struct task;包含指向进程描述符的指针

unsigned long stack[]2018;

}

##### current 宏

8kb的联合区域，使用13位来确认基地址。

current产生汇编指令:

movl $oxffffe000 , %ecx

andl %esp,%ecx

movl %ecx,p

执行以上命令后，p中位进程描述符指针。



free_task_struct（）

释放8kb的task_union内存区，若高速缓存未满，放入高速缓存中。

alloc_task_struct()

分配8kb的task_union内存区。若至少有一半填满，这个函数从高缓中获得内存。

##### 注

movl  val,   %ebx     ，引用从开始位置的4字节数据，不可传送小于4字节。

movw  %ax,    %bx      ，16位，2字节

 movb   %al,    %lx       ，8位一字节

##### 进程链表

进程描述符包含一个链表指针，指向下一个进程的域。

双向链表把所有进程联系起来。

SET_LINKS,插入进程描述符

REMOVE_LINKS,删除一个进程描述符

#define for_each_task(p)

{

for(p=&ini_task;(p=p->next_task)!=&init_stack;)

}//遍历进程链表

##### TASK_RUNNING状态的进程链表

内核查找一个进程在cpu上运行，只需查找可运行进程。故构造此链表，方便查找，也叫运行队列:renqueue。next_run和prev_run实现可运行队列。

add_to_queue把一个进程进程描述符插入到链表的开始。

del_from_runqueue把第一个进程描述符删除.

move_first_runqueue把描述符移动到队首

move_last_queue把描述符移动到队尾。

wake_up_process使进程可执行，把进程设为TASK_RUNNING。

##### pidhash表及连接表

 内核需要通过进程的pid导出进程描述符指针，比如kill服务，传入pid杀死进程。

顺序扫描进程链表太慢，所以我们构建pidhash，在常数时间内查找指针。

pidhash散列表有PIDHASH_SZ个元素。

pid_hashfn宏把pid转成表的索引：多行宏用\结尾。

#define pid_hashfn(x)    \

(   ( (   (x)>>8)^(x)   )   &      ( PIDHAHS_SZ-1)     )

Linux使用连接表chained list处理hash冲突。连接表是一个双向链表，由冲突的表象的进程描述符构成。使用pidhash_next和pidhash_pprev域实现。

这种方法比线性映射更好，因为更节省空间。

hash_pid：插入一个进程。

unhash_pid:删除一个进程。

find_task_by_pid：查找pid对应的进程描述符指针。

##### task空闲表项的链表

为了快速增加和删除，每当进程被撤销，将空闲向加入链表。他是一个非循环双向链表。

##### 进程的亲属关系

进程具有父子关系，同一进程的子进程又有兄弟关系。

进程0，1是由内核创建的，0是所有进程的祖先。

进程描述符中包含描述亲属关系的域，其构成如下：

p_opptr 祖先

指向创建此进程的进程描述符，若父进程不存在，指向1进程。

例如shell启动后台进程后推出，后台进程该域指向init。

p_pptr  父进程

当前父进程，一般与p_opptr相同，但有些情况不同。

例如：当另一个进程发布ptrace系统调用请求监控p时。

p_cptr  子进程

指向年龄最小的子进程的描述符。

p_ysptr  弟进程

指向它父进程的下一个创建进程。

p_osptr 兄进程

指向它父进程的上一个创建进程。

##### 等待队列

TASK_RUNNING组成运行队列

TASK_STOPPED和TASK_ZOMBIE不用创建独立的链表。因为，可以通过父进程查找pid，或进程间的亲属关系检索子进程。

TASK_INTERRUPTIBLE和TASK_UNINTERRUPTIBLE创建独立的链表。而且对于不同的等待事件，创建独立的链表，称为等待队列。

等待队列对中断处理，进程同步及定时用处大。等待队列由循环链表实现，元素指向进程描述符。

c语言定义如下：

struct wait_queue{

struct task_struct * task;

struct wait_queue *next;

}

每一个等待队列由一个等待队列指针标识，指向第一个元素地址，或为空。



intel指针的大小为4字节。

init_waitqueue()函数初始化一个空的等待队列，它接受等待队列指针的地址q作为参数，然后把指针设为q-4.

add_wait_queue(q,entry)函数把地址为entry的元素插入等待队列。



等待队列关中断执行插入操作：

if(*q!=NULL)

 		entry->next=*q;  指向队首元素

else 

​		entry->next=(struct wait_queue *)(q-1);  指向空指针

*q=entry;    插入到队首



remove_wait_queue移除由entry指向的元素，执行此操作必须关中断。

next=entry->next;

head=next;

while((tmp=head->next)!=entry)

​	head=tmp;

head->next=next;

此函数查找到循环链表中位于entry前一个的元素，让其next指向entry->next，删除entry。



希望等待事件可以调用一下函数：

sleep_on，设置为TASK_INTERRUPTIBLE,插入等待队列。调用调度恢复程序，当当前进程被唤醒，从等待队列中删除。

interruptible_sleep_on，设为TASK_UNINTERRUPTIBLE

sleep_on_timeout和interruptible_sleep_on_timeout,定时唤醒，使用schedule_timeout()实现。使用wake_up或wake_up_interruptible宏。

##### 进程的使用限制

进程与一组使用限制相关联，决定进程能使用的系统资源数量。

例举部分如下：

RLIMIT_CPU,cpu使用最长时间

RLIMIT_FSIZE，文件最大值

RLIMIE_DATA,堆最大值

RLIMIT_STACK，栈大小的最大值

RLIMIT_CCRE，内存信息转储文件的大小

RLIMIT_RSS，页框最大数

RLIMIT_NPROC，拥有进程最大数

RLIMIT_NOFILE，打开文件最大数

RLIMIT_MEMLOCK，非交换内存最大尺寸

RLIMIT_AS，进程地址空间最大尺寸

使用限制存放在进程描述符的rlim域，通常大多数限制值为RLIMIT_INFINITY,无限制。



### 进程切换

主要内容：硬件上下文，硬件支持，linux代码，保存浮点寄存器

##### 硬件上下文

>进程恢复执行前必须装入寄存器的一组数据称为硬件上下文。
>
>硬件上下文是执行上下文的一部分呢。
>
>linux中，硬件上下文部分存放在tss段，其余保存在内核态堆栈。tss段与进程描述符tss域一致。

每个进程都可以拥有自己的地址空间，但进程必须共享cpu寄存器。因此，恢复执行前，内核必须确认每个寄存器装入了挂起进程时的值。

##### 任务状态段

>tss,部分存储执行上下文。每个tss有自己的8字节任务段描述符：tssd，描述符包含指向tss起始地址的基地址域和限制域。tssd的s位为0，表示对应tss为系统段。

tssd指向正在运行进程tss，type置为11，否则置为9.type最低两位为忙位，用来区分9和11.

tssd存储在gdt中，gdt基地址放在gdt寄存器中。tr寄存器：任务寄存器，保存cpu上正在运行的进程的tssd选择符。通过这种方式，直接对tss寻址，无需检索gdt中tssd段。

##### switch_to宏

>执行进程切换，利用prev，next参数。prev，next为进程描述符指针。
>
>schedule调用这个宏以调度一个新的进程在cpu上运行。
>
>EIP寄存器主要用于存放当前代码段即将被执行的下一条指令的偏移

执行步骤：保存内核态堆栈中的esi，edi，ebp寄存器内容。在tss.esp保存esp内容。

把nxt的esp载入，eip等载入内核态堆栈。

esi：源变址寄存器

edi：目的变址寄存器

### linux创建进程

clone函数创建轻量级进程，他有四个参数。

fn，指定一个新进程执行的函数，当这个函数返回时，子进程终止。函数返回一个整数，表示退出代码。

arg，传递给fn的数据的指针。

flags，各种信息，低字节指定子进程结束时发送到父进程的信号编号，通常为SIGCHILD信号。剩余三个字节给一组克隆标志编码，指定父子进程公用资源。

CLONE_VM，内存描述符和所偶页表

CLONE_FS，识别根目录和当前工作目录的表

CLONE_FILES，识别打开文件表

CLONE_SIGHAND，识别信号处理表

CLONE_PID，pid

CLONE_PTRACE，如果ptrace系统调用引起父进程追送，子进程也被跟踪

CLONE_VFORK，用在vfork系统调用。



child_stack，用户态堆栈指针赋给子进程esp。若为0，栈指针赋给子进程，即公用用户态堆栈。

##### do_fork

执行步骤：

1指定了CLONE_PID,则检查父进程pid是否不为空，若部位空，返回错误码，因为0进程：swapper进程  才能使用CLONE_PID标志。两个轻量级进程不能pid相同。

2调用alloc_task_struct获得union task_union内存区存放进程描述符和内核态堆栈。

3当前指针指向父进程描述符，将父进程描述符拷贝到分配的内存区的新进程描述符中。

4有几个检查以确认用户具有开始执行一个进程所必须的资源。

curren->rlim[RLIMIT_NPROC].RLIM_CUR是否小于当前进程数。

5检查系统中进程总数是否小于NR_TASKS减去TASKS_LEFT_FOR_ROOT.若是，查找空闲项插入。

6.。。。。太多了，看书

##### 内核线程

内核线程只运行在内核态，使用PAGE_OFFSET的线性地址以后的空间。

kernel_thread创建一个新的内核线程，并只能由另一个内核线程来调用。

##### 进程0

>所有进程的祖先，也称swapper进程。

它由start_kernel创建,其数据结构如下：

init_task_union：包含进程描述符和内核态堆栈。init_stack,inti_task分别产生堆栈和描述符。

进程描述符指向如下列表：init_mm,ini_mmap,init_fs,init_files,init_signals

由以下的宏初始化这些表，INIT_MM,INIT_MMAP......

一个tss段，由INIT_TSS初始化

两个段描述符，TSSD,LDTD,存放在gdt中。

页全局目录，存放在swapper_pg_dir

##### 进程1

>init进程，由进程0创建

初始化四个必要的内核线程

kflushd:bdflush

刷新脏缓冲区内的内容到磁盘以归还内存。

Kupdate

刷新旧的脏缓冲区内容到磁盘，减少不一致风险。

kpiod

把属于共享内存映射的页面交换出去

Kswapd

执行内存回收功能

init执行execve系统调用装入可执行程序init，因而编程一个普通进程。

### 撤销进程

当进程被终止，如exit或执行到主过程最后一句，执行exit。进程就已经死了，内核要回收进程所拥有资源，内存，文件或其他零碎东西。

##### 进程终止

内核用do_exit来，其操作为：

1flag设为PF_EXITING

2删除进程描述符，通过sem_exit从ipc信号量队列删除

3检查分页，文件系统，文件描述符，若未共享，删除。

4state域设为TASK_ZOMBIE

5exit_code设为进程终止代号

5调用exit_notifu更行父子关系

7调用schedule选择新的进程运行

##### 删除进程

在上一项，子进程完成了任务进入僵死，但不能删除进程描述符。必须等待父进程调用wait获取子进程执行结果，才可以释放。

若父进程先死了怎么办，答会有很多孤儿进程，他们的task项塞满了系统。所以，我们强迫孤儿进程成为init进程的子进程，init来调用wait检查它的合法进程终止，来撤销僵死堵塞的进程。

release释放僵死进程的描述符

1free_uid，进程数减一。

2add_fee_taskslot，释放task中进程描述符项

3减nr_tasks变量的值

4unhash_pid，从pidhash散列表中删除该进程描述符。

5调用REMOVE_LINKS,从进程链表删除该进程

6free_task_struct，释放8kb进程描述符和内核态堆栈的内存区。



# 中断和异常

>中断分为同步中断和一部中断
>
>同步和异步中断通常称为异常和中断，有时用中断信号统称这两种。



### 中断信号的作用

>中断信号提供方式，使cpu执行正常控制流之外的代码。

中断需要保存程序计数器当前值，eip和cs寄存器内容。并把中断类型相关的值放入程序计数器。

##### 中断和进程切换对比

相比进程切换，中断更轻light，所需上下文更少。

##### 中断处理的约束

中断处理时内核的敏感操作，有如下约束。

1内核收到中断信号时，需要尽快执行完当前任务，他会将部分后续任务稍后执行。

内核活动分两部分，上半部分和下半部分。上半部分立即执行，下半部分留着稍后处理。

2尽可能避免中断时又发生中断，中断处理程序必须编写成内核控制路径能以嵌套方式执行。

当最后一个内核控制路径终止时，内核必须能恢复被中断进程的执行。或，如果中断信号已导致调度，内核能切换。

3避免中断后又中断，限制临界区，因为内核以开中断运行。

### 中断和异常向量

>每个中断和异常由0-255之间一个数标识。

linux使用以下向量

0-31：异常和不可屏蔽中断

32-47：向量分配给可屏蔽中断，即由IRQ引起的中断

48-255：软中断。

### IRQ和中断

>每个能发出中断请求的硬件设备控制器都有一个指派为IRQ的输出线。IRQ与中断控制器的硬件电路的输入引脚相连。

中断控制器执行下列动作

1监视IRQ线，检查产生的信号。

2若IRQ产生信号：将信号转为向量存放在中断控制器的I/O端口，送达INTR引脚，发出中断，等待cpu确认此信号。

3返回第一步

### 异常

intel发布了20种不同异常。内核为每种异常提供特定处理程序。

例如：0-试图除0  3-断点命令  

##### eflags

>OF,DF,IF,TF,SF,ZF,0,AF,0,PF,1,CF
>
>溢出，方向，中断使能，单步，符号，零标志，辅助进位，奇偶，进位标志。

### 中断描述符表

>类似于gdt和ldt，idt每项对应一个中断或异常向量，每个向量为8字节（0-255）。idtr寄存器保存idt物理基地址及其限制。idt包含了三种类型的描述符。

任务们描述符，中断门描述符，陷阱们描述符

##### 任务们

包含了一个进程的tss，中断发生时，取代当前进程的tss。linux不使用任务门

##### 中断门

包含段选择符和一个中断或异常处理程序的段内偏移量。

##### 陷阱们

除非控制权传递到一个适当的段，否则处理器不修改IF标志。

##### IF标志

### 中断或异常的硬件处理

##### CPL

>current privilege level，当前执行的任务的特权等级，存储在cs和ss的第0位或第一位上。二进制两位表示0-3.

##### DPL

>门或段的特权级别，存储在idt或gdt的dpl字段中。

### 中断和异常处理程序的嵌套执行

>一条内核控制路径由运行在内核态的指令序列组成，这些指令处理一个中断或一个异常。例如，当进程发出一个系统调用的请求时，控制路径的指令就是把寄存器内容保存到内核态堆栈的指令，而最后一部分就是恢复寄存器内容并让cpu返回用户态的那些指令。

##### 缺页异常

当进程查找属于他的地址空间的页，但是在ram中没有此页。内核态唯一异常。

为了实现无优先级的中断模型，每个中断都可以被其他中断程序延缓。

### 初始化中断描述符

内核启动中断前，将idt表地址装到idtr寄存器，初始化表项。

int指令允许用户发送中断信号，值为0-255任意一个向量。

##### linux中断，陷阱及系统门

中断门：用户态进程不能访问的中断门dpl=0，中断处理都由中断门激活，限制在内核态。

系统门：用户态进程可访问的陷阱们dpl=3，系统门激活linux 4个异常处理程序，3，4，5，128

陷阱门：用户态进程不能访问陷阱门dpl=0。除了上面4个之外，所有的异常程序都通过陷阱们激活。

set_intr_gate(n,addr)，在第n个idt表项中，插入一个中断门。dpl=0

set_system_gate(n,addr)，在第n个idt表项中，插入陷阱门。dpl=3

set_trap_gate(n,addr)，dpl=0.

### IDT的初步初始化

IDT存放在idt_table表中，有256个表项。

##### 汇编

1. INC 自增1   increase
2. DEC 自减1  decrease
3. JGE 前>=后  Jump if  greater or equal
4. JG 前>后   Jump if  greater
5. JLE 前<=后  Jump if  less or equal
6. JL 前<后  Jump if  less
7. JNE 前不等于后  Jump if not equal
8. JE 前等于后  Jump if equal

### 异常处理

>目标：1向进程发送信号同胞反常情况
>
>2处理分页请求

目标一举例，除0操作，菜谱产生异常，异常处理程序向进程发送SIGFPE信号。

异常处理程序结构

1汇编保存内核堆栈

2c函数处理异常

3ret_from_exception（）从高级语言推出

##### 为异常处理程序保存寄存器的值

