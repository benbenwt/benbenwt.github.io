[TOC]
# Imooc
>使用Spark SQL分析Imooc访问日志,数据以日志文件形式提供，共一千万条访问日志，5G数据量。
>主要完成如下指标统计：
>1.某天最后欢迎的TopN课程
>2.某天各个省市各自的TopN课程
>3.按照流量统计TopN课程
>4.某天最受欢迎的文章
>5.某天进行code最多的课程
>6.某天最勤奋的IP

>在使用spark开发时，可以以shell脚本形式编写sql进行数据处理，也可以使用scala借助rdd，table sql等处理数据，对于实时数仓也要使用scala操作DStream进行数据处理。

## 日志

>日志不是json格式的，是日志插件打印的原生格式。一般如果使用了自定义的埋点采集数据，都会为了规范定义统一的json格式，如果没有定义，那么就只能拿日志插件输出的内容了。
```
60.165.39.1 - - [10/Nov/2016:00:01:53 +0800] "POST /course/ajaxmediauser HTTP/1.1" 200 54 "www.imooc.com" "http://www.imooc.com/code/1431" mid=1431&time=60 "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.122 Safari/537.36 SE 2.X MetaSr 1.0" "-" 10.100.136.64:80 200 0.014 0.014
14.145.74.175 - - [10/Nov/2016:00:01:53 +0800] "POST /course/ajaxmediauser/ HTTP/1.1" 200 54 "www.imooc.com" "http://www.imooc.com/video/678" mid=678&time=60&learn_time=551.5 "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36" "-" 10.100.136.64:80 200 0.014 0.014.145.74.175 - - [10/Nov/2016:00:01:53 +0800] "POST /course/ajaxmediauser/ HTTP/1.1" 200 54 "www.imooc.com" "http://www.imooc.com/video/678" mid=678&time=60&learn_time=551.5 "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36" "-" 10.100.136.64:80 200 0.014 0.014 
```


### 日志清洗
>url,traffic,ip等多个值之间是用"空格"分隔开的，以此为依据取出对应的值。其中time属性，需要编写format解析格式，并转换为规范的格式。
>然后过滤局域网的的ip，和不符合要求的记录。因为后边要根据公网ip映射对应的地区城市，所以进行了过滤。
>最终集中到一个分区上，输出到同一个文件中。
```
package com.imooc

import com.imooc.conf.pathConfig
import com.imooc.utils.{DateUtils, FileUtils}
import org.apache.spark.{SparkConf, SparkContext}

object CleanRawLog {
  def main(args: Array[String]): Unit = {
    println("CleanRawLog")
    FileUtils.deleteDir(pathConfig.rawCleanOutputPath)
    val sparkConf:SparkConf=new SparkConf().setAppName("CleanRawLog").setMaster("local[*]")
    val sc=new SparkContext(sparkConf)
    println(sc)
//    每行为rdd的一个元素
    val rawLog=sc.textFile(pathConfig.protocol+pathConfig.rawPath)
//    rawLog.take(10).foreach(println)

//    想调试split的结果,观察split列表对应的值
    val splitsList=rawLog.map(line=>{
      val splits=line.split(" ")
      splits
    })
//    val temp=splitsList.take(10)
//调试完了，取所需的值。
// 值在split列表中对应的index位置
//0 ip
//3 4 time
//9 traffic
//12 url
    val parseResultList=splitsList.map(splits=>{
      val ip=splits(0)
      val time=splits(3)+splits(4)
      val traffic=splits(9)
      val url=splits(12).replaceAll("\"","")
//      时间需要格式化，url中去掉"
      List(DateUtils.parse(time),url,traffic,ip)
    })
//    过滤
    parseResultList.filter(result => !"10.100.0.1".equals(result(3)))
      .filter(result => !"-".equals(result(1)))
      .map(result => result(0)+"\t"+result(1)+"\t"+result(2)+"\t"+result(3))
      .repartition(1)
      .saveAsTextFile(pathConfig.protocol+pathConfig.rawCleanOutputPath)
  }
}

```

>为了得到更丰富的信息，对上一步的结果进行解析，获得更多的属性。
>包括对url内容进行解析，获得cmsType，cmsId，根据ip映射城市，根据时间解析日期等

```
package com.whirly.util

import com.ggstar.util.ip.IpHelper
import org.apache.commons.lang3.StringUtils
import org.apache.spark.sql.Row
import org.apache.spark.sql.types.{LongType, StringType, StructField, StructType}

/**
  * 访问日志转换(输入==>输出)工具类
  */
object AccessConvertUtil {
  //定义的输出的字段
  val struct = StructType(
    Array(
      StructField("url", StringType),
      StructField("cmsType", StringType),
      StructField("cmsId", LongType),
      StructField("traffic", LongType),
      StructField("ip", StringType),
      StructField("city", StringType),
      StructField("time", StringType),
      StructField("day", StringType)
    )
  )


  /**
    * 根据输入的每一行信息转换成输出的样式
    *
    * @param log 输入的每一行记录信息: 1970-01-01 08:00:00	http://www.imooc.com/code/547	54	119.130.229.90
    */
  def parseLog(log: String) = {

    try {
      val splits = log.split("\t")

      val url = splits(1)
      val traffic = splits(2).toLong
      val ip = splits(3)

      // http://www.imooc.com/code/547   ===>  code/547  547
      var cmsType = ""
      var cmsId = 0l

      val domain = "http://www.imooc.com/"
      val domainIndex = url.indexOf(domain)
      if (domainIndex >= 0) {
        val cms = url.substring(domainIndex + domain.length)
        val cmsTypeId = cms.split("/")

        if (cmsTypeId.length > 1) {
          cmsType = cmsTypeId(0)
          if ("video".equals(cmsType) || "code".equals(cmsType) || "learn".equals(cmsType)) {
            try {
              cmsId = cmsTypeId(1).toLong
            } catch {
              case e: Exception => {}
            }
          } else if ("article".equals(cmsType)) {
            val number = RegexUtil.findStartNumber(cmsTypeId(1))
            if (StringUtils.isNotEmpty(number)) {
              cmsId = number.toLong
            }
          }
        }
      } /*else {
        val domain = "http://coding.imooc.com/"
        val domainIndex = url.indexOf(domain)
        if (domainIndex >= 0) {
          val cms = url.substring(domainIndex + domain.length)
          val cmsTypeId = cms.split("/")
          if (cmsTypeId.length > 1) {
            cmsType = cmsTypeId(0)
            if ("lesson".equals(cmsType)) {
              cmsId = cmsTypeId(1).toLong
            }
          }
        }
      }*/

      val city = IpHelper.findRegionByIp(ip)
      //IpUtils.getCity(ip)
      val time = splits(0)
      val day = time.substring(0, 10).replaceAll("-", "")

      //这个row里面的字段要和struct中的字段对应上
      Row(url, cmsType, cmsId, traffic, ip, city, time, day)
    } catch {
      case e: Exception => {
        println("------------log----------------------")
        println(log)
        Row(0)
      }
    }
  }
}

```
























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































